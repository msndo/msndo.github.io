# 非同期とPromise


## もの！
### Promise demo（codepen）
<a href="https://codepen.io/msndo/pen/eYMeEGg" target="_blank">https://codepen.io/msndo/pen/eYMeEGg</a>


14行目付近を片方ずつ試してみてください！

```
    // 普通に書いてやってみる（ダメ例）
    elemTrigger.addEventListener('click', execStraight);

    // 非同期チェーン（「正解例」）
    // elemTrigger.addEventListener('click', execPromised);
```

## 何をする？
非同期処理を一個ずつ順番に実行するようにバトンを渡しながら行くようにする

## なぜ要る？
非同期処理はただ並べて書いただけだと流れを無視して勝手にわーっと走り始めてしまうから。

## 非同期って言葉が
よくわからない言葉ですよね。

コンピュータは、（実は！）「機械」で、
この機械にいくつかの動作を「順番に」やらせるには「合図」が必要になります。

ようするに前の動作が「終わった」という「合図」を受けて次の動作が始まるという構図です。
このような自動フローを機械で組むには必ずなんらかの合図が存在するわけです。

## デフォは「同期」
多くのプログラム言語はコマンドを上から並べていって適宜分岐やループを挟んでいくという形をとっています。

内部的には並んだコマンドがそれぞれ終わるごとに合図を発して次に待ち受けた処理がそれを受け止める、
つまりコマンド同士が息を合わせながらやるというのがデフォに作られています。

この仕組みが「息を『合わせる』 → 連動する → sync → 同期」とされています。
ですがいつもはこんな「息を合わせてる」なんてのは気にする機会はないと思います

## 非同期 - 同期をキャンセルしたいケース
さて、多くは順番に実行していって問題ないのですが、
たまに「すごく時間がかかる処理」や「いつ終わるかわからない処理」というのもあり、
そういったものは流れから一旦はぐれさせて見切り発車でやっておきたい仕事というのもあるわけです。
（たとえばどんなのがあるでしょう？？）

で、 setTimeout や ajax はその典型になるわけです。
setTimeoutはいつもだったら数秒程度の待ちで使っているわけですが、やろうと思えば半日待たせることもできはします。

ajaxもサーバが重いといつ返ってくるかわからない、という場合も考えられます。なのこれらは流れからはぐれさせて「非同期」でやる、という仕様です。

## 息を合わせなおす！
そして！「同期」を一度キャンセルしたんだけどその「はぐれ処理」を起点にした別系統の流れをつくりたい、という
場合も出るわけです（ワガママ、、）。

別系統の流れを作る方法はいくつかあるのですがその一つが「Promise」です。


## Promiseは何をやってるか
Promiseはブザーみたいなものです。このブザーは処理が終わったら呼び出し側に（親に）「buzzzzzz」という音は出ませんが合図を出します。行儀のいい子ですね。個人的にはもうちょっと独立心持ってもいいと思いますよ。

というわけでPromiseを使う時は何はともあれまずPromiseを書いて「ブザーを親に渡す」ということをする必要があります。
Promiseをreturnしておく、という書き方になります。

主目的の非同期処理はPromiseの中身に書きます。下の例ではsetTimeout()がそれ。


基本系（setTimeoutの「後」に何かやりたい）

```
// 呼び出し側。END1, END2を1秒ずつ挟んで出力

// sleep()で1秒待つ。このsleep関数はPromiseブザーを携えている
sleep(1000)

// then()はPromiseが正常ブザー(resolve())を鳴らすのを待ち受ける。
.then(function() {
  // console.logのような普通の処理はPromiseブザーがないので
  console.log('END1');

  // その場でブザーを鳴らす必要がある
  return Promise.resolve();
})
.then(function() {
  return sleep(1000); // sleep()はPromiseブザーを携えているので1行で流れを作れる
})
.then(function() {
  console.log('END2');
});

// 呼ばれる側。主目的の非同期処理（ここではsetTimeout()）とそれをラップするPromise()がある。
// まずPromiseを書いてある。監視してもらえるように親にブザーを渡している（マゾ）
function sleep() {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve();
    }, 1000);
  });
}
```

## まとめ
例の中のsleep() はまず完了通知ブザーPromiseを親に渡しておきます。
Promiseの中で具体的な処理が実行されます。 resolve（正常終了）でブザーが鳴って
呼び出し側では受け皿の then() の中身が実行されるという構造です。

とは言ってもやってみないとわかりづらいところなので Promise() や then() の中身を書き換えたりして把握してください！

## 付記
Ajaxなどではサーバが落ちてたときなどのバッドエンドルート「reject() と catch()」 を作る必要があるのですが
それはまた別の機会で。
（ただAjaxで正常ルートだけを実装するということは少なくともプロダクションコードではありえないない、
というところだけお見知り置きを。。
